<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lonquan.github.io</id>
    <title>半壁峰林-龙权的自留地</title>
    <updated>2020-03-01T19:57:17.182Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lonquan.github.io"/>
    <link rel="self" href="https://lonquan.github.io/atom.xml"/>
    <subtitle>半壁峰林-龙权的自留地</subtitle>
    <logo>https://lonquan.github.io/images/avatar.png</logo>
    <icon>https://lonquan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 半壁峰林-龙权的自留地</rights>
    <entry>
        <title type="html"><![CDATA[Redis 的数据导入导出]]></title>
        <id>https://lonquan.github.io/post/redis-de-shu-ju-dao-ru-dao-chu/</id>
        <link href="https://lonquan.github.io/post/redis-de-shu-ju-dao-ru-dao-chu/">
        </link>
        <updated>2016-03-25T16:52:36.000Z</updated>
        <content type="html"><![CDATA[<p>开启现有 Redis 实例的 AOF 功能（<em>如果实例已经启用 AOF 功能则忽略此步骤</em>）</p>
<blockquote>
<p># redis-cli -h ip -p port config set appendonly yes `</p>
</blockquote>
<p>通过AOF文件将数据导入到新的 Redis 实例 (假定生成的 AOF 文件名为 append.aof)</p>
<blockquote>
<p># redis-cli -h ip -p 6379 -a pass --pipe &lt; appendonly.aof</p>
</blockquote>
<p>####append.aof 文件分析<br>
假设 redis 内存有「name:Jhon」的键值对，那么进行 AOF 持久化后，AOF 文件有如下内容：</p>
<p><code>*2 # 2个参数 $6 # 第一个参数长度为 6 SELECT # 第一个参数 $1 # 第二参数长度为 1 8 # 第二参数 *3 # 3个参数 $3 # 第一个参数长度为 4 SET # 第一个参数 $4 # 第二参数长度为 4 name # 第二个参数 $4 # 第三个参数长度为 4 Jhon # 第二参数长度为 4</code><br>
所以对上面的内容进行恢复，能得到熟悉的一条 redis 命令：SELECT 8;SET name Jhon.<br>
可以想象的是，redis 遍历内存数据集中的每个 key-value 对，依次写入磁盘中；redis 启动的时候，从 AOF 文件中读取数据，恢复数据。</p>
<p>修改</p>
<p>*2     # 2个参数<br>
$6     # 第一个参数长度为 6<br>
SELECT     # 第一个参数<br>
$1     # 第二参数长度为 1<br>
8     # 第二参数</p>
<p>为</p>
<p>*2     # 2个参数<br>
$6     # 第一个参数长度为 6<br>
SELECT     # 第一个参数<br>
$2    # 第二参数长度为 1<br>
15    # 第二参数</p>
<p>可以将 数据导入到 15号 db</p>
<blockquote>
<p>可能会有多个 select DB, 需要仔细查看</p>
</blockquote>
<blockquote>
<p>redis-cli -h 127.0.0.1 -p 6379 shutdown  停止 redis</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录 js 的自执行方式]]></title>
        <id>https://lonquan.github.io/post/js-immediately-invoke/</id>
        <link href="https://lonquan.github.io/post/js-immediately-invoke/">
        </link>
        <updated>2016-03-24T19:48:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-javascript">// Either of the following two patterns can be used to immediately invoke
  // a function expression, utilizing the function's execution context to
  // create &quot;privacy.&quot;

  (function(){ /* code */ }()); // Crockford recommends this one
  (function(){ /* code */ })(); // But this one works just as well

  // Because the point of the parens or coercing operators is to disambiguate
  // between function expressions and function declarations, they can be
  // omitted when the parser already expects an expression (but please see the
  // &quot;important note&quot; below).

  var i = function(){ return 10; }();
  true &amp;&amp; function(){ /* code */ }();
  0, function(){ /* code */ }();

  // If you don't care about the return value, or the possibility of making
  // your code slightly harder to read, you can save a byte by just prefixing
  // the function with a unary operator.

  !function(){ /* code */ }();
  ~function(){ /* code */ }();
  -function(){ /* code */ }();
  +function(){ /* code */ }();

  // Here's another variation, from @kuvos - I'm not sure of the performance
  // implications, if any, of using the `new` keyword, but it works.
  // http://twitter.com/kuvos/status/18209252090847232

  new function(){ /* code */ }
  new function(){ /* code */ }() // Only need parens if passing arguments
</code></pre>
]]></content>
    </entry>
</feed>